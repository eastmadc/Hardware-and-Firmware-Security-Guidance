#Input: An EFI Signature List file generated by Powershell's Get-SecureBootUEFI, Keytool, or some UEFI configuration interfaces. 
#Output: Certificates and hashes embedded in each ESL file. ESL files may contain multiple ESL structures in sequence. 
#Assumptions: 1 certificate per ESL structure. Unlimited hashes in each ESL. Unlimited ESLs in series. 

param ( 
    [Parameter(Mandatory = $true)][string]$inFile, 
    [Parameter(Mandatory = $true)][string]$outPrefix, 
    [switch]$debugMode = $false 
) 

#read the input file 
try { 
    [byte[]]$byteArray = Get-Content -Path $inFile -Encoding Byte -ErrorAction Stop 
} 
catch { 
    Write-Host "Error: Could not load the input file." 
    exit 1 
} 
  
#make sure the provided ESL contains at least one hash 
if ($byteArray.Length -lt 76) { 
    Write-Host "Error: Input file is too small." 
    exit 2 
} 
  
#set up some counter variables 
[int]$inputLength = $byteArray.Length 
[int]$headIndex = 0 
[int]$certCounter = 0 
[int]$hashCounter = 0 
  
if($debugMode) { Write-Host "Input file size is $inputLength" } 
  
#ESL files could contain multiple ESL structures in sequence 
do { 
    #each individual ESL structure must be certificates or hashes -- not both simultaneously 
    $certMode = $false 
    $hashMode = $false 
  
    if($byteArray[$headIndex] -eq 161) { 
        #activate cert mode 
        if($debugMode) { Write-Host "Found certificate GUID" } 
        $certMode = $true 
    } 
    elseif($byteArray[$headIndex] -eq 38) { 
        #activate hash mode 
        if($debugMode) { Write-Host "Found hash GUID" } 
        $hashMode = $true 
    } 
    else { 
        #the input file does not conform EFI_GUID found as the first memeber of the EFI_SIGNATURE_LIST structure 
        Write-Host "Error: Unrecognized EFI_GUID signature type." 
        exit 3 
    } 
  
    #we know the EFI_GUID so get the signature list size 
    [int]$sigListSize = 0 
    $sigListSize += [int]$byteArray[$headIndex + 16] 
    $sigListSize += [int]$byteArray[$headIndex + 17] * 256 
    $sigListSize += [int]$byteArray[$headIndex + 18] * 65536 
    $sigListSize += [int]$byteArray[$headIndex + 19] * 16777216 
    if($debugMode) { Write-Host "Signature list size is $sigListSize" } 
  
    #signature header is next (it's probably zero but might not be) 
    [int]$sigHeaderSize = 0 
    $sigHeaderSize += [int]$byteArray[$headIndex + 20] 
    $sigHeaderSize += [int]$byteArray[$headIndex + 21] * 256 
    $sigHeaderSize += [int]$byteArray[$headIndex + 22] * 65536 
    $sigHeaderSize += [int]$byteArray[$headIndex + 23] * 16777216 
    if($debugMode) { Write-Host "Signature header size is $sigHeaderSize" } 
  
    #signature size is next 
    [int]$sigSize = 0 
    $sigSize += [int]$byteArray[$headIndex + 24] 
    $sigSize += [int]$byteArray[$headIndex + 25] * 256 
    $sigSize += [int]$byteArray[$headIndex + 26] * 65536 
    $sigSize += [int]$byteArray[$headIndex + 27] * 16777216 
    if($debugMode) { Write-Host "Signature size is $sigSize" } 
  
    #ignore the signature header 
  
    #ignore the originator UUID 
  
    #export data 
    if($certMode) { 
        #certificate exporter (44 is all the stuff that comes before the certificate) 
        $certName = "$outPrefix$certCounter.cer" 
        [byte[]]$outCertificate = $byteArray[($headIndex + 44 + $sigHeaderSize)..($headIndex + $sigListSize)] 
        Set-Content -Path $certName -Value $outCertificate -Encoding Byte 
        if($debugMode) { Write-Host "Wrote certificate $certName" } 
        $certCounter += 1 
  
    } elseif($hashMode){ 
        [int]$totalHashes = ($sigListSize - 28) / $sigSize 
        if($debugMode) { Write-Host "Total hashes in this ESL are $totalHashes" } 
  
        for([int]$i = 0; $i -lt $totalHashes; $i++) { 
            #hash exporter (28 is the stuff that comes before the hashes and 16 is the originator UUID) 
            $hashName = "$outPrefix$hashCounter.hsh" 
  
            write-Host ($headIndex + 28 + $sigHeaderSize + ($i * $sigSize) + 16) "   " ($headIndex + 28 + $sigHeaderSize + ($i * $sigSize) + 47) 
  
            [byte[]]$outHash = $byteArray[($headIndex + 28 + $sigHeaderSize + ($i * $sigSize) + 16)..($headIndex + 28 + $sigHeaderSize + ($i * $sigSize) + 47)] 
            Set-Content -Path $hashName -Value $outHash -Encoding Byte 
            if($debugmode) { Write-Host "Wrote hash $hashName" } 
            $hashCounter += 1 
        } 
    } 
  
    #advance the head index 
    $headIndex += $sigListSize; 
  
} while($headIndex -lt $byteArray.Length) 
  
if($headIndex -ne $inputLength) { 
    Write-Host "Error parsing contents. Some data may be truncated." 
    exit 4 
} 
